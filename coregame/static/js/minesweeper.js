/**
 * Minesweeper Game.
 *
 * App's central class
 *
 * September 06, 2022 by Marcio Reis Jr.
 */

/**
 * Minesweeper game class.
 */
class Minesweeper {
    /**
     * Instantiate a Minesweeper game.
     *
     * @param {Number} dimension - Length of the sides of the board. Default: 7.
     * @param {Object} elements - With following attributes:
     *      - evListenerElement: {HTMLElement} Main <div> to hook up the event
     *          handler.
     *      - boardBody: {HTMLElement} Table body where the cells will be load.
     *      - timerDisplay: {HTMLElement} <div> Where the timer will show up.
     *      - minesDisplay: {HTMLElement} <div> Where the mine counter shows up.
     *      - resultNotification: {Function} Callback for win/lose notification.
     *          This Callback has the following signature:
     *              resultNotification(result, size, mines, time)
     *              Default: undefined.
     *      - stickyShiftKey: {Object} Object that reports if a 'virtual shift key'
     *          is pressed to activate the flag on cells. Returns true/false.
     */
    constructor(dimension = 7, elements = { evListenerElement, boardBody,
        timerDisplay, minesDisplay, resultNotification, stickyShiftKey }) {
        this.evListenerElement = elements.evListenerElement;
        this.boardBody = elements.boardBody;
        this.timerDisplay = elements.timerDisplay;
        this.minesDisplay = elements.minesDisplay;
        this.resultNotification = elements.resultNotification || null;
        // private attributes
        this.stickyShiftKey = elements.stickyShiftKey;
        this.startTime = Date.now();
        this.endTime = Date.now();
        this.timerHandler = -1;
        this.boardDimension = dimension;
        this.board = [];
        this.state = 'start'; // 'start', 'running', 'win', 'lose'
        this.mineRatio = 15; // percentage of total cells
        this.mineCount = 0; // Counter based on user flags (displayed on screen)
        this.mineTotal = 0; // Actual amount of mines on the board
        // initialize other functionalities
        this.commonInit_();
        // event registration
        this.evListenerElement.addEventListener('click', this);
        this.evListenerElement.addEventListener('dblclick', this);
    }

    /**
     * Function to implement EventListener object type.
     *
     * @param {Event} event - Event generated by the DOM.
     */
    handleEvent(event) {
        if (event.target.dataset.cellPos) {
            this.processCellEvent_(event);
        }
        if (event.target.id === 'start-button') {
            this.processStartButton_(event);
        }
    }

    /**
     * Set new dimension to the board and restart the game.
     *
     * @param {Number} dim - New dimension to the board.
     */
    setDimension(dim) {
        this.boardDimension = parseInt(dim);
        this.processStartButton_();
    }

    /**
     * Disconnect the object from the DOM and destroy internal resources.
     */
    destroyObject() {
        this.evListenerElement.removeEventListener('click', this);
        this.evListenerElement.removeEventListener('dblclick', this);
        this.timerStop_();
        this.board = null;
        this.evListenerElement = null;
        this.boardBody = null;
        this.timerDisplay = null;
        this.minesDisplay = null;
        this.resultNotification = null;
    }

    ///////////////////////////////////////////////////////////////////////////
    //  Private methods

    /**
     * Return the difference between two timestamp in minutes:seconds.
     *
     * @param {Date} start - Start time timestamp.
     * @param {Date} end - Ending time timestamp.
     * @returns {String} The elapsed time in '0:00' minutes.
     */
    computeTimeDiff_(start, end) {
        if (end < start) { end = start }
        const sec = (end - start) / 1000; //Date in milliseconds
        const min = Math.floor(sec / 60);
        const remSec = Math.floor(sec % 60);
        return `${min}:${remSec.toString().padStart(2, '0')}`;
    }

    /**
     * Handle timer event to drive the game elapsed time.
     */
    timerHandler_() {
        this.timerDisplay.innerHTML = this.computeTimeDiff_(this.startTime,
            Date.now());
    }

    /**
     * Start the game time.
     */
    timerStart_() {
        if (this.timerHandler !== -1) { return; } // already running
        this.timerClear_();
        // one second interval
        this.timerHandler = setInterval(() => { this.timerHandler_(); }, 1000);
        this.startTime = Date.now();
    }

    /**
     * Stop the game time.
     */
    timerStop_() {
        if (this.timerHandler !== -1) {
            clearInterval(this.timerHandler);
            this.timerHandler = -1;
        }
        this.endTime = Date.now();
    }

    /**
     * Clear the game time.
     */
    timerClear_() {
        this.timerDisplay.innerHTML = '0:00';
        this.startTime = this.endTime = 0;
    }

    /**
     * Randomly fill the board with mines and the associated numbered cells.
     *
     * It also calculates the amount of mines based on a ratio
     * (this.mineRatio).
     */
    placeCellsAndMines_() {
        // Fill out board with blank cells
        for (let row = 0; row < this.boardDimension; row++) {
            for (let col = 0; col < this.boardDimension; col++) {
                this.board[row][col] = new BlankCell(row, col, this.board);
            }
        }
        // compute amount of mines
        let mineCount = Math.ceil(
            Math.pow(this.boardDimension, 2) * this.mineRatio / 100);
        this.mineCount = mineCount; // Controlled by amount of user flags
        this.mineTotal = mineCount; // Actual amount for bookkeeping purposes
        // place mines randomly on the board, replacing some BlankCells
        do {
            let row = Math.floor(Math.random() * this.boardDimension);
            let col = Math.floor(Math.random() * this.boardDimension);
            if (this.board[row][col] instanceof MineCell) {
                mineCount++; // try one more time to place a none
            } else {
                this.board[row][col] = new MineCell(row, col, this.board)
                    .enumerate(); // enumerate surrounding cells
            }
        } while (--mineCount);
    }

    /**
     * Create the initial plain square board.
     *
     * This also initializes the board Array with zeros.
     *
     * @param {Number} dimension - Length of the sides of the board.
     */
    fillInitialBoard_(dimension) {
        const cellTmpl = document.querySelector('#cellTmpl');
        if (cellTmpl === null) {
            throw new ReferenceError(
                "Missing template of cell <template id='cellTmpl'></template>");
        }
        let HTMLcode = '';
        for (let row = 0; row < dimension; row++) {
            HTMLcode += '<tr>';
            for (let col = 0; col < dimension; col++) {
                const cellTemplate = cellTmpl.innerHTML
                    .replace(/\$\{row\}/g, row)
                    .replace(/\$\{col\}/g, col);
                HTMLcode += cellTemplate;
            }
            HTMLcode += '</tr>';
        }
        this.boardBody.innerHTML = HTMLcode;
        this.board = [];
        for (let ii = 0; ii < dimension; ii++) {
            let nArr = Array(dimension).fill(0);
            this.board.push(nArr);
        }
        this.placeCellsAndMines_();
    }

    /**
     * Update the amount of mines flagged on the screen.
     */
    updateMineDisplay_(deductFlags = false) {
        let flagCount = 0;
        if (deductFlags) {
            for (let rows of this.board) {
                for (let cell of rows) {
                    if (cell.isFlagged) { flagCount++ }
                }
            }
        }
        this.mineCount = this.mineTotal - flagCount;
        if (this.mineCount < 0) { this.mineCount = 0; }
        this.minesDisplay.innerHTML = this.mineCount;
    }

    /**
     * Reveal all cell on the board (show mines, blanks and numbers).
     *
     * @param {Array} classAddition - Array of additional CSS classes to add to
     *      revealed elements.
     */
    revealAll_(classAddition = null) {
        for (let row of this.board) {
            for (let cell of row) {
                cell.reveal(classAddition);
            }
        }
        this.updateMineDisplay_();
    }

    /**
     * Process events from the board cells.
     *
     * @param {Event} event - Events from the DOM.
     */
    processCellEvent_(event) {
        let target = event.target;
        const regex = /r(\d+)-c(\d+)/; // look for 'r0-c0' like coordinates
        const [_, row, col] = regex[Symbol.match](target.dataset.cellPos);
        const stickyShiftKey = (this.stickyShiftKey ?
            this.stickyShiftKey.peekStickyShiftKey() : false);
        const consolidatedShift = event.shiftKey ||
            (stickyShiftKey && event.type === 'click');

        if (this.state === 'start') {
            this.timerStart_();
            this.state = 'running';
            this.raiseEvent('minesweeperrunning');
        }
        if (this.state === 'running') {
            const outcome = this.board[row][col].click(consolidatedShift);
            // evaluate/update changes on the number of flags
            this.updateMineDisplay_(true);
            // no additional action needed if 'shift' was pressed (change flag)
            if (consolidatedShift) { return; }
            // click on a cell WITHOUT shiftKey
            if (outcome === 1) {
                // mine blew off
                this.timerStop_();
                this.state = 'lose';
                this.revealAll_();
                this.raiseEvent('minesweeperlose');
                // call resultNotification
                if (this.resultNotification instanceof Function) {
                    this.resultNotification('lose', this.boardDimension,
                        this.mineTotal, this.computeTimeDiff_(this.startTime,
                            this.endTime));
                }
                return;
            }
            // check for end of game
            this.checkForaWin_();
        }
    }

    /**
     * Raise an event to notify different states of the game.
     *
     * @param {String} event - The event to raise.
     *
     * @note The event is raised on the boardBody element and bubbles up.
     * @note The following events are raised during the game:
     *  - minesweeperstart,
     *  - minesweeperrunning,
     *  - minesweeperwin,
     *  - minesweeperlose.
     */
    raiseEvent(event) {
        if (!document.implementation.hasFeature('CustomEvents', '3.0')) {
            return;
        }

        const ev = new window.CustomEvent(event, {bubbles: true, cancelable: true,
            detail: {boardSize: this.boardDimension, mineCount: this.mineTotal,
            timing: this.computeTimeDiff_(this.startTime, this.endTime)}});
        this.boardBody.dispatchEvent(ev);
    }

    /**
     * Check for a winner.
     *
     * The idea if finding a winner scenario is to scan for all cell on the
     * board and find out if the only unrevealed cells are the cell with mine,
     * which means the user found them all.
     */
    checkForaWin_() {
        let unrevealed = 0;
        for (let row of this.board) {
            for (let cell of row) {
                if (!cell.isRevealed()) { unrevealed++; }
            }
        }
        if (unrevealed === this.mineTotal) {
            this.timerStop_();
            this.state = 'win';
            this.revealAll_(['text-success']);
            this.raiseEvent('minesweeperwin');
            // call resultNotification(result, size, mines, time)
            if (this.resultNotification instanceof Function) {
                this.resultNotification('win', this.boardDimension,
                    this.mineTotal, this.computeTimeDiff_(this.startTime,
                        this.endTime));
            }
        }
    }

    /**
     * Game initialization steps common to the constructor and the start button.
     */
    commonInit_() {
        this.timerStop_();
        this.timerClear_();
        this.fillInitialBoard_(this.boardDimension);
        this.updateMineDisplay_();
        this.raiseEvent('minesweeperstart');
    }

    /**
     * Process start-button events.
     *
     * @param {Event} event - Events from the DOM.
     */
    processStartButton_(event) {
        this.state = 'start'; // 'start', 'running', 'win', 'lose'
        this.commonInit_();
    }
}
